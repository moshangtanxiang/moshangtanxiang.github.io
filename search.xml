<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2Fblog%2F2020%2F01%2F19%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[文件预览&ensp;&ensp;&ensp;&ensp;以下方法调用基本都适用文件预览，更改所需文件地址即可。 12345678910111213141516previewResume(fj_url) &#123; var suffix = &quot;&quot;; let officeList = [&quot;doc&quot;, &quot;docx&quot;, &quot;xls&quot;, &quot;xlsx&quot;, &quot;ppt&quot;, &quot;pptx&quot;]; let imgList = [&quot;png&quot;, &quot;jpg&quot;, &quot;jpeg&quot;, &quot;bmp&quot;]; var fileArr = fj_url.split(&quot;.&quot;); var suffix = fileArr[fileArr.length - 1]; if (officeList.indexOf(suffix) != -1) &#123; window.open( &quot;https://view.officeapps.live.com/op/view.aspx?src=&quot; + fj_url ); &#125; else if (imgList.indexOf(suffix) != -1) &#123; window.open(fj_url); &#125; else &#123; window.open(fj_url); &#125; &#125;, 文件上传1234567// 封装定义 公共 接口export default &#123; // 附件上传 fileUpload(data) &#123; return fetch(&apos;post&apos;, &apos;URL/upload&apos;, data) &#125;,&#125; 文件导出一：接口调用1234567891011121314if (method === &apos;download&apos;) &#123; axios(&#123; url: url, method: &apos;post&apos;, data: params, responseType: &apos;blob&apos; &#125;).then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) .catch((error) =&gt; &#123; reject(error) &#125;) &ensp;&ensp;&ensp;&ensp;如上是自己定义了一种类型，封装之时判断，相应处理；再api调用。 123projectPatrol_export(params) &#123; return fetch(&apos;download&apos;, URL + &apos;/export&apos;, params); &#125;, 12345678910111213141516171819export(id, name) &#123; let data = &#123; projectId: id, patrolId: this.search.patrolId, patrolName: this.search.patrolName, patrolType: this.search.patrolType, responsible: this.search.responsible &#125;; api.projectPatrol_export(data).then(res =&gt; &#123; let url = window.URL.createObjectURL(res); let link = document.createElement(&quot;a&quot;); link.style.display = &quot;none&quot;; link.href = url; link.download = name+&apos;.xls&apos;; document.body.appendChild(link); link.click(); window.URL.revokeObjectURL(link.href); &#125;);&#125;, &ensp;&ensp;&ensp;&ensp;上述方法是创建节点进行导出，name文件名自定义，正常方法调用。 二：隐藏表单提交123456789101112&lt;form :action=&quot;this.URL&apos;&quot; target=&quot;_blank&quot; id=&quot;formdata&quot; method =&quot;post&quot; style=&quot;display: none&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;staffName&quot; :value=&quot;number&quot; /&gt;&lt;/form&gt;// 导出按钮&lt;Button type=&quot;primary&quot; @click=&quot;reportEmploryExport()&quot;&gt; &lt;img src=&quot;../static/image/daochu2.png&quot; style=&quot;margin-bottom:2px&quot;/&gt; 导出&lt;/Button&gt;reportEmploryExport() &#123; $(&apos;#formdata&apos;).submit();&#125;,]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>file相关操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面缓存]]></title>
    <url>%2Fblog%2F2019%2F11%2F15%2Fset_cookie%2F</url>
    <content type="text"><![CDATA[前端页面常用缓存，具体设置哪种根据项目需求而定 cookie缓存：cookie设置12345setCookie(name,value)&#123; var exp = new Date(); exp.setTime(exp.getTime() + 2*30*24*60*60*1000); document.cookie = name + &quot;=&quot;+ escape (value) + &quot;;expires=&quot; + exp.toGMTString();&#125;, cookie获取1234567getCookie(name)&#123; var arr,reg=new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;); if(arr=document.cookie.match(reg)) return unescape(arr[2]); else return null;&#125;, localstorage缓存:// 缓存数据字典 api.dictionary_get({type:’Gender’}).then(res=&gt;{ localStorage.setItem(“Gender”, JSON.stringify(res.data)); })// 单一死数据 localStorage.setItem(“Gender”, “data”); localStorage.getItem(&quot;Gender&quot;);]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iview对接]]></title>
    <url>%2Fblog%2F2019%2F10%2F31%2Fiview%E5%AF%B9%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[表格数据123456789&lt;Table stripe :columns=&quot;columns1&quot; :data=&quot;list&quot;&gt;&lt;/Table&gt;&lt;div class=&quot;block&quot; style=&quot;text-align: center;margin: 20px auto;&quot;&gt; &lt;Page :total=&quot;total&quot; // 分页 :page-size=&quot;pageSize&quot; @on-change=&quot;changepage&quot; show-total show-elevator :current=&quot;pageNum&quot; /&gt;&lt;/div&gt; &ensp;&ensp;&ensp;&ensp;html部分由上，columns的title代表表头，key绑定接受后台传入字段名，数据部分绑定list，自动循环。&ensp;&ensp;&ensp;&ensp;操作按钮需要手写，如其他字段一样；如数据无误，打印params会有相关行内数据，获取相关数据进行操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576data() &#123; return&#123; list: [], columns1: [ &#123; title: &apos;缺工岗位类别&apos;, align:&quot;center&quot;, key: &apos;general&apos;, children: [ &#123; title: &apos;普工&apos;, key: &apos;lackWorker&apos;, align: &apos;center&apos;, &#125;, &#123; title: &apos;技术&apos;, key: &apos;lackTechnician&apos;, align: &apos;center&apos;, &#125;, &#123; title: &apos;管理人员&apos;, key: &apos;lackManager&apos;, align: &apos;center&apos;, width:110 &#125;, &#123; title: &apos;其他&apos;, key: &apos;lackOther&apos;, align: &apos;center&apos;, &#125; ] &#125;, &#123; title: &apos;操作&apos;, key: &apos;other2&apos;, align: &apos;center&apos;, render: (h, params) =&gt; &#123; return h(&quot;div&quot;, [ h( &quot;Button&quot;, &#123; props: &#123; type: &quot;primary&quot;, size: &quot;small&quot; &#125;, style: &#123; marginRight: &quot;5px&quot;, width:&quot;24px&quot;, height:&quot;24px&quot;, color:&quot;#ffffff&quot;, backgroundColor:&quot;#12BD42&quot;, backgroundRadius:&quot;4px&quot;, borderRadius:&quot;4px&quot; &#125;, on: &#123; click: () =&gt; &#123; this.modal2 = true; let id = params.row.id api.qi_planEditor(&#123;id: id&#125;).then((res) =&gt; &#123; this.formValidate2= res.data; &#125;) &#125; &#125; &#125;, ) ]); &#125; &#125; ] &#125; &#125; &ensp;&ensp;&ensp;&ensp;如需进行表格相关操作，如上 rander函数内进行。 以下翻页，其他data、接口等方面同vue类似。 12345678910//页码 changepage(value) &#123; let datas = &#123; pageNum: value, pageSize: this.pageSize, &#125; api.qi_plan(datas).then(res=&gt;&#123; this.list = res.data.list; &#125;) &#125;,]]></content>
      <categories>
        <category>iview</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[echarts点击切换路由]]></title>
    <url>%2Fblog%2F2019%2F08%2F12%2Fecharts%E7%82%B9%E5%87%BB%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;vue中使用echarts，然后点击echars图表进行切换路由（以funnel为例）： &ensp;&ensp;&ensp;&ensp;跳转界面因所需对dom节点操作，所以使用了mounted；&ensp;&ensp;&ensp;&ensp;为过滤器赋值（路由跳转传入），如果直接在方法中赋值会比较死板，过滤器一直绑定传入数据： &ensp;&ensp;&ensp;&ensp;使用activated（进入当前存在activated()函数的页面时，一进入页面就触发）： &ensp;&ensp;&ensp;&ensp;但是重新刷新此页面时会发现，mounted和catived都会执行；因此，加上判断即可。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computed() VS methods()]]></title>
    <url>%2Fblog%2F2019%2F08%2F06%2Fcomputed-VSmethods-%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;可以使用 methods 来替代 computed(计算机属性)，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。 Date.now() 不是响应式依赖，这样的computed不会再次更新： 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 响应式依赖： 123456computed: &#123; reversedMessage: function () &#123; return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) //这里的message是同一个组件里面的data()里边定义好了的一个变量 &#125;&#125; &ensp;&ensp;&ensp;&ensp;message每次变动的时候，都会执行一次computed，把它刚获得的新值再“倒置”。&ensp;&ensp;&ensp;&ensp;相比而言，只要发生重新渲染，method 调用总会执行该函数。 &ensp;&ensp;&ensp;&ensp;没有使用到计算属性的依赖缓存的时候，可以使用定义方法来代替计算属性，在 methods 里定义一个方法可以实现相同的效果，甚至该方法还可以接受参数，使用起来更灵活。 computed必须返回一个值页面绑定的才能取得值，而methods中可以只执行逻辑代码，返回值可有可无。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[created()与mounted()]]></title>
    <url>%2Fblog%2F2019%2F08%2F05%2Fcreated-%E4%B8%8Emounted-%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;created()：在创建vue对象时，当html渲染之前就触发；但是注意，全局vue.js不强制刷新或者重启时只创建一次，也就是说，created()只会触发一次；created 这个钩子在实例被创建之后被调用。一般可以在created函数中调用ajax获取页面初始化所需的数据。示例： 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div id=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; name: hello &#125; &#125;, created: function()&#123; console. log( document. getElementById(&quot;name&quot;).innerHTML); &#125; &#125;&lt;script&gt; 出现如下报错： 12345678910TypeError: Cannot read property &apos;innerHTML Of null&apos;at Vue Component created (parent, vue?cad: 17)at callHook (vue, esm. is2efeb: 2921)at VueComponent. Vue, init (yue, esm. is2efeb: 4630)at new Vue Component (yue, esm, is?feb: 4798)at createComponent InstanceForVnode (yue, esm. is2efeb: 4310)at init (yue, esm, is?feb: 4131)at createComponent (yue, esm, is?feb: 5608)at createElm (yue, esm.is2efeb: 5555)at createChildren (vue esm is2efeb 5682) 挂载阶段还没开始，也就是说，模板还没有被渲染成html；也就是这时候通过id什么的去查找页面元素是找不到的 mounted()：mounted钩子函数一般是用来向后端发起请求拿到数据以后做一些业务处理，该钩子函数是在挂载完成以后也就是模板渲染完成以后才会被调用（vue的生命周期中一个实例的mounted只会运行一次）示例： 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div id=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; name: hello &#125; &#125;, mounted: function()&#123; console. log( document. getElementById(&quot;name&quot;).innerHTML); &#125; &#125;&lt;script&gt; 结果是：hello取到了值，这说明这时候vue模板已经渲染完毕。因此，Dom操作一般是在mounted钩子函数中进行的 &ensp;&ensp;&ensp;&ensp;通常created使用的次数多，而mounted通常是在一些插件的使用或者组件的使用中进行操作，比如插件chart.js的使用: var ctx = document.getElementById(ID);通常会有这一步，而如果你写入组件中，你会发现在created中无法对chart进行一些初始化配置，一定要等这个html渲染完后才可以进行，那么mounted就是不二之选。&ensp;&ensp;&ensp;&ensp;methods:{}中的方法都需要主动去触发，比如点击click之类的而created(){}、mounted(){}、里面的代码都是自动去执行的，即vue生命周期到了哪一步就直接去执行对应钩子函数里面的代码了，无需手动去执行&ensp;&ensp;&ensp;&ensp;created中主要放初始化获取数据之类，mounted()中挂载到具体的DOM节点]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue钩子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css_vh]]></title>
    <url>%2Fblog%2F2019%2F07%2F31%2Fcss-vh%2F</url>
    <content type="text"><![CDATA[css中height 100vh的应用场景，动态高度百分比布局，浏览器视区大小单位 height:100vh一些只能vw, vh才能完成的应用场景：场景之：元素的尺寸限制vw vh 主要是实现了动态高度百分比布局，比如宽高比不固定的图片，vw很轻易的实现正方形图片缩略图原始大图的尺寸限制问题——因为很有可能图片过大，尼玛一屏显示器区域不够放，我们需要对其进行缩放处理。这类限制的实现，在当下，需要获得图片的原始大小，以及浏览器内部尺寸，算大小，算比例等，算是比较折腾的。但是，vw, vh等单位本身就是浏览器视区大小相关单位，直接使用其做限制，岂不省了N多JS代码？CSS代码：.vw_vh_img {max-width: 90vw;max-height: 90%;max-height: 90vh;} CSS3新vw, vh单位与纯CSS定位的弹框屏幕居中效果实例页面视区覆盖以及边界定位vh确实是相对于屏幕的，但默认body有一个margin，100%加上这个margin就超出了就会出现滚动条。清除body的margin即可。body{margin:0;} 在做手机端的时候经常会用到的做字体的尺寸单位em说白了 em就相当于“倍”，比如设置当前的div的字体大小为1.5em，则当前的div的字体大小为：当前div继承的字体大小*1.5但是当div进行嵌套的时候，em始终是按照当前div继承的字体大小来缩放，参照后面的例子。 rem这里的r就是root的意思，意思是相对于根节点来进行缩放，当有嵌套关系的时候，嵌套关系的元素的字体大小始终按照根节点的字体大小进行缩放。参照后面给的demo vhvh就是当前屏幕可见高度的1%，也就是说height:100vh == height:100%;但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，但是设置height:100vh，该元素会被撑开屏幕高度一致。 vwvw就是当前屏幕宽度的1%补充一句，当设置width:100%，被设置元素的宽度是按照父元素的宽度来设置，但是100vw是相对于屏幕可见宽度来设置的，所以会出现50vw 比50%大的情况 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;!DOCTYPE html&gt;&lt;html lang=&quot;Zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;一程烟雨&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;html&#123;font-size: 14px;&#125;.em,.em &gt; .em-son,.em &gt; .em-son &gt; .em-grandson &#123;font-size: 1.2em;&#125;.rem,.rem &gt; .rem-son,.rem &gt; .rem-son &gt; .rem-grandson &#123;font-size: 1.2rem;&#125;.rem-box &#123;background: #d60b3b;width:10rem;height: 10rem;color: #fff;text-align: center;line-height:5rem;&#125;.vhvw-box &#123;background: #d60b3b;width:50vw;height: 50vh;color: #fff;text-align: center;line-height:25vh;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;em 继承父元素的字体大小，来变大或变小，多层嵌套字体变化&lt;/h1&gt;&lt;div class=&quot;em&quot;&gt;字体大小 1.2 * 14（父元素body） = 16px&lt;div class=&quot;em-son&quot;&gt;字体大小 1.2 * 16(父元素em) = 20px&lt;div class=&quot;em-grandson&quot;&gt;字体大小 1.2 * 20(父元素em-son) = 24px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 继承根节点元素的字体大小，来变大或变小，多层嵌套字体不变化&lt;/h1&gt;&lt;div class=&quot;rem&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-son&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-grandson&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 也可作为固定长度单位设置宽高等&lt;/h1&gt;&lt;div class=&quot;rem-box&quot;&gt;宽：14 * 10 = 140px&lt;br&gt;高：14 * 10 = 140px&lt;/div&gt;&lt;br&gt;&lt;h1&gt;vh,vw 屏幕可见区域的高度，宽度的1%&lt;/h1&gt;&lt;div class=&quot;vhvw-box&quot;&gt;宽：屏幕宽度的50%&lt;br&gt;高：屏幕高度的50%&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;Zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;一程烟雨&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;html&#123;font-size: 14px;&#125;.em,.em &gt; .em-son,.em &gt; .em-son &gt; .em-grandson &#123;font-size: 1.2em;&#125;.rem,.rem &gt; .rem-son,.rem &gt; .rem-son &gt; .rem-grandson &#123;font-size: 1.2rem;&#125;.rem-box &#123;background: #d60b3b;width:10rem;height: 10rem;color: #fff;text-align: center;line-height:5rem;&#125;.vhvw-box &#123;background: #d60b3b;width:50vw;height: 50vh;color: #fff;text-align: center;line-height:25vh;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;em 继承父元素的字体大小，来变大或变小，多层嵌套字体变化&lt;/h1&gt;&lt;div class=&quot;em&quot;&gt;字体大小 1.2 * 14（父元素body） = 16px&lt;div class=&quot;em-son&quot;&gt;字体大小 1.2 * 16(父元素em) = 20px&lt;div class=&quot;em-grandson&quot;&gt;字体大小 1.2 * 20(父元素em-son) = 24px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 继承根节点元素的字体大小，来变大或变小，多层嵌套字体不变化&lt;/h1&gt;&lt;div class=&quot;rem&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-son&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-grandson&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 也可作为固定长度单位设置宽高等&lt;/h1&gt;&lt;div class=&quot;rem-box&quot;&gt;宽：14 * 10 = 140px&lt;br&gt;高：14 * 10 = 140px&lt;/div&gt;&lt;br&gt;&lt;h1&gt;vh,vw 屏幕可见区域的高度，宽度的1%&lt;/h1&gt;&lt;div class=&quot;vhvw-box&quot;&gt;宽：屏幕宽度的50%&lt;br&gt;高：屏幕高度的50%&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令操作]]></title>
    <url>%2Fblog%2F2019%2F07%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Linux使用者逐渐增多，对Linux熟练掌握成为必然，随后，那就必须学会它的操作命令。虽然可能会花费一些时间，不过从长远的角度来说，这的确是一件事半功倍的事情，它会让我们更了解Linux，更灵活地去使用Linux。Linux提供了很多命令，接下来简单介绍下Linux的操作命令，系统学习。 查看进程相关windows操作系统下，已知端口号，查看进程号，以及关闭进程 netstat -ano|findstr 端口号tskill 进程号 /f 杀死所有进程及子进程 /t 强制杀死 /im 用镜像名称作为进程信息 /pid 用进程id作为进程信息 linux操作系统下： 1、已知端口号，查看进程号 命令行：netstat -tunlp|grep 端口号 或 lsof -i :端口号 等等2、关闭该进程 命令行：sudo kill 进程号 注意：如果没有关闭掉，请使用命令&apos;sudo kill -9 进程号&apos;，强制关闭掉3、查看端口是否已经被占用 命令行：netstat -tln|grep 端口号系统操作命令123456789系统# uname -a # 查看内核/操作系统/CPU信息# head -n 1 /etc/issue # 查看操作系统版本# cat /proc/cpuinfo # 查看CPU信息# hostname # 查看计算机名# lspci -tv # 列出所有PCI设备# lsusb -tv # 列出所有USB设备# lsmod # 列出加载的内核模块# env # 查看环境变量 12345678资源# free -m # 查看内存使用量和交换区使用量# df -h # 查看各分区使用情况# du -sh &lt;目录名&gt; # 查看指定目录的大小# grep MemTotal /proc/meminfo # 查看内存总量# grep MemFree /proc/meminfo # 查看空闲内存量# uptime # 查看系统运行时间、用户数、负载# cat /proc/loadavg # 查看系统负载 123456磁盘和分区# mount | column -t # 查看挂接的分区状态# fdisk -l # 查看所有分区# swapon -s # 查看所有交换分区# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)# dmesg | grep IDE # 查看启动时IDE设备检测状况 1234567网络# ifconfig # 查看所有网络接口的属性# iptables -L # 查看防火墙设置# route -n # 查看路由表# netstat -lntp # 查看所有监听端口# netstat -antp # 查看所有已经建立的连接# netstat -s # 查看网络统计信息 123456进程# ps -ef # 查看所有进程# top # 实时显示进程状态# ps -e | grep apt # 查看apt-get相关进程# sudo fuser -k 8000/tcp #关闭和端口8000相关进程 1234567用户# w # 查看活动用户# id &lt;用户名&gt; # 查看指定用户信息# last # 查看用户登录日志# cut -d: -f1 /etc/passwd # 查看系统所有用户# cut -d: -f1 /etc/group # 查看系统所有组# crontab -l # 查看当前用户的计划任务 123服务# chkconfig --list # 列出所有系统服务# chkconfig --list | grep on # 列出所有启动的系统服务 12程序# rpm -qa # 查看所有安装的软件包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux操作命令</tag>
      </tags>
  </entry>
</search>
