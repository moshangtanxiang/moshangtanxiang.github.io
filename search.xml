<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[created()与mounted()]]></title>
    <url>%2F2019%2F08%2F05%2Fcreated-%E4%B8%8Emounted-%2F</url>
    <content type="text"><![CDATA[created()：在创建vue对象时，当html渲染之前就触发；但是注意，全局vue.js不强制刷新或者重启时只创建一次，也就是说，created()只会触发一次；created 这个钩子在实例被创建之后被调用。一般可以在created函数中调用ajax获取页面初始化所需的数据。示例： 1234567891011121314151617&lt;template&gt;( )&lt;div class=&quot;parent&quot;&gt;( )( )&lt;div id=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;( )&lt;/div&gt;&lt;/template&gt;&lt;script&gt;( )export default&#123;( )( )data()&#123;( )( )( )return&#123;( )( )( )( )name: hello( )( )( )&#125;( )( )&#125;,( )( )created: function()&#123;( )( )( )console. log( document. getElementById(&quot;name&quot;).innerHTML);( )( )&#125;( )&#125;&lt;script&gt; 出现如下报错： 12345678910TypeError: Cannot read property &apos;innerHTML Of null&apos;at Vue Component created (parent, vue?cad: 17)at callHook (vue, esm. is2efeb: 2921)at VueComponent. Vue, init (yue, esm. is2efeb: 4630)at new Vue Component (yue, esm, is?feb: 4798)at createComponent InstanceForVnode (yue, esm. is2efeb: 4310)at init (yue, esm, is?feb: 4131)at createComponent (yue, esm, is?feb: 5608)at createElm (yue, esm.is2efeb: 5555)at createChildren (vue esm is2efeb 5682) 挂载阶段还没开始，也就是说，模板还没有被渲染成html；也就是这时候通过id什么的去查找页面元素是找不到的 mounted()：mounted钩子函数一般是用来向后端发起请求拿到数据以后做一些业务处理，该钩子函数是在挂载完成以后也就是模板渲染完成以后才会被调用（vue的生命周期中一个实例的mounted只会运行一次）示例： 1234567891011121314151617&lt;template&gt;( )&lt;div class=&quot;parent&quot;&gt;( )( )&lt;div id=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/div&gt;( )&lt;/div&gt;&lt;/template&gt;&lt;script&gt;( )export default&#123;( )( )data()&#123;( )( )( )return&#123;( )( )( )( )name: hello( )( )( )&#125;( )( )&#125;,( )( )mounted: function()&#123;( )( )( )console. log( document. getElementById(&quot;name&quot;).innerHTML);( )( )&#125;( )&#125;&lt;script&gt; 结果是：hello取到了值，这说明这时候vue模板已经渲染完毕。因此，Dom操作一般是在mounted钩子函数中进行的 通常created使用的次数多，而mounted通常是在一些插件的使用或者组件的使用中进行操作，比如插件chart.js的使用: var ctx = document.getElementById(ID);通常会有这一步，而如果你写入组件中，你会发现在created中无法对chart进行一些初始化配置，一定要等这个html渲染完后才可以进行，那么mounted就是不二之选。methods:{}中的方法都需要主动去触发，比如点击click之类的而created(){}、mounted(){}、里面的代码都是自动去执行的，即vue生命周期到了哪一步就直接去执行对应钩子函数里面的代码了，无需手动去执行created中主要放初始化获取数据之类，mounted()中挂载到具体的DOM节点]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue钩子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css_vh]]></title>
    <url>%2F2019%2F07%2F31%2Fcss-vh%2F</url>
    <content type="text"><![CDATA[css中height 100vh的应用场景，动态高度百分比布局，浏览器视区大小单位 height:100vh一些只能vw, vh才能完成的应用场景：场景之：元素的尺寸限制vw vh 主要是实现了动态高度百分比布局，比如宽高比不固定的图片，vw很轻易的实现正方形图片缩略图原始大图的尺寸限制问题——因为很有可能图片过大，尼玛一屏显示器区域不够放，我们需要对其进行缩放处理。这类限制的实现，在当下，需要获得图片的原始大小，以及浏览器内部尺寸，算大小，算比例等，算是比较折腾的。但是，vw, vh等单位本身就是浏览器视区大小相关单位，直接使用其做限制，岂不省了N多JS代码？CSS代码：.vw_vh_img {max-width: 90vw;max-height: 90%;max-height: 90vh;} CSS3新vw, vh单位与纯CSS定位的弹框屏幕居中效果实例页面视区覆盖以及边界定位vh确实是相对于屏幕的，但默认body有一个margin，100%加上这个margin就超出了就会出现滚动条。清除body的margin即可。body{margin:0;} 在做手机端的时候经常会用到的做字体的尺寸单位em说白了 em就相当于“倍”，比如设置当前的div的字体大小为1.5em，则当前的div的字体大小为：当前div继承的字体大小*1.5但是当div进行嵌套的时候，em始终是按照当前div继承的字体大小来缩放，参照后面的例子。 rem这里的r就是root的意思，意思是相对于根节点来进行缩放，当有嵌套关系的时候，嵌套关系的元素的字体大小始终按照根节点的字体大小进行缩放。参照后面给的demo vhvh就是当前屏幕可见高度的1%，也就是说height:100vh == height:100%;但是有个好处是当元素没有内容时候，设置height:100%该元素不会被撑开，但是设置height:100vh，该元素会被撑开屏幕高度一致。 vwvw就是当前屏幕宽度的1%补充一句，当设置width:100%，被设置元素的宽度是按照父元素的宽度来设置，但是100vw是相对于屏幕可见宽度来设置的，所以会出现50vw 比50%大的情况 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;!DOCTYPE html&gt;&lt;html lang=&quot;Zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;一程烟雨&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;html&#123;font-size: 14px;&#125;.em,.em &gt; .em-son,.em &gt; .em-son &gt; .em-grandson &#123;font-size: 1.2em;&#125;.rem,.rem &gt; .rem-son,.rem &gt; .rem-son &gt; .rem-grandson &#123;font-size: 1.2rem;&#125;.rem-box &#123;background: #d60b3b;width:10rem;height: 10rem;color: #fff;text-align: center;line-height:5rem;&#125;.vhvw-box &#123;background: #d60b3b;width:50vw;height: 50vh;color: #fff;text-align: center;line-height:25vh;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;em 继承父元素的字体大小，来变大或变小，多层嵌套字体变化&lt;/h1&gt;&lt;div class=&quot;em&quot;&gt;字体大小 1.2 * 14（父元素body） = 16px&lt;div class=&quot;em-son&quot;&gt;字体大小 1.2 * 16(父元素em) = 20px&lt;div class=&quot;em-grandson&quot;&gt;字体大小 1.2 * 20(父元素em-son) = 24px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 继承根节点元素的字体大小，来变大或变小，多层嵌套字体不变化&lt;/h1&gt;&lt;div class=&quot;rem&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-son&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-grandson&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 也可作为固定长度单位设置宽高等&lt;/h1&gt;&lt;div class=&quot;rem-box&quot;&gt;宽：14 * 10 = 140px&lt;br&gt;高：14 * 10 = 140px&lt;/div&gt;&lt;br&gt;&lt;h1&gt;vh,vw 屏幕可见区域的高度，宽度的1%&lt;/h1&gt;&lt;div class=&quot;vhvw-box&quot;&gt;宽：屏幕宽度的50%&lt;br&gt;高：屏幕高度的50%&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;Zh-cn&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;一程烟雨&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;html&#123;font-size: 14px;&#125;.em,.em &gt; .em-son,.em &gt; .em-son &gt; .em-grandson &#123;font-size: 1.2em;&#125;.rem,.rem &gt; .rem-son,.rem &gt; .rem-son &gt; .rem-grandson &#123;font-size: 1.2rem;&#125;.rem-box &#123;background: #d60b3b;width:10rem;height: 10rem;color: #fff;text-align: center;line-height:5rem;&#125;.vhvw-box &#123;background: #d60b3b;width:50vw;height: 50vh;color: #fff;text-align: center;line-height:25vh;&#125;&lt;/style&gt;&lt;body&gt;&lt;h1&gt;em 继承父元素的字体大小，来变大或变小，多层嵌套字体变化&lt;/h1&gt;&lt;div class=&quot;em&quot;&gt;字体大小 1.2 * 14（父元素body） = 16px&lt;div class=&quot;em-son&quot;&gt;字体大小 1.2 * 16(父元素em) = 20px&lt;div class=&quot;em-grandson&quot;&gt;字体大小 1.2 * 20(父元素em-son) = 24px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 继承根节点元素的字体大小，来变大或变小，多层嵌套字体不变化&lt;/h1&gt;&lt;div class=&quot;rem&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-son&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;div class=&quot;rem-grandson&quot;&gt;字体大小 1.2 * 14（根节点html） = 16px&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;h1&gt;rem 也可作为固定长度单位设置宽高等&lt;/h1&gt;&lt;div class=&quot;rem-box&quot;&gt;宽：14 * 10 = 140px&lt;br&gt;高：14 * 10 = 140px&lt;/div&gt;&lt;br&gt;&lt;h1&gt;vh,vw 屏幕可见区域的高度，宽度的1%&lt;/h1&gt;&lt;div class=&quot;vhvw-box&quot;&gt;宽：屏幕宽度的50%&lt;br&gt;高：屏幕高度的50%&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令操作]]></title>
    <url>%2F2019%2F07%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Linux使用者逐渐增多，对Linux熟练掌握成为必然，随后，那就必须学会它的操作命令。虽然可能会花费一些时间，不过从长远的角度来说，这的确是一件事半功倍的事情，它会让我们更了解Linux，更灵活地去使用Linux。Linux提供了很多命令，接下来简单介绍下Linux的操作命令，系统学习。 查看进程相关windows操作系统下，已知端口号，查看进程号，以及关闭进程 netstat -ano|findstr 端口号tskill 进程号 /f 杀死所有进程及子进程 /t 强制杀死 /im 用镜像名称作为进程信息 /pid 用进程id作为进程信息 linux操作系统下： 1、已知端口号，查看进程号 命令行：netstat -tunlp|grep 端口号 或 lsof -i :端口号 等等2、关闭该进程 命令行：sudo kill 进程号 注意：如果没有关闭掉，请使用命令&apos;sudo kill -9 进程号&apos;，强制关闭掉3、查看端口是否已经被占用 命令行：netstat -tln|grep 端口号系统操作命令123456789系统# uname -a # 查看内核/操作系统/CPU信息# head -n 1 /etc/issue # 查看操作系统版本# cat /proc/cpuinfo # 查看CPU信息# hostname # 查看计算机名# lspci -tv # 列出所有PCI设备# lsusb -tv # 列出所有USB设备# lsmod # 列出加载的内核模块# env # 查看环境变量 12345678资源# free -m # 查看内存使用量和交换区使用量# df -h # 查看各分区使用情况# du -sh &lt;目录名&gt; # 查看指定目录的大小# grep MemTotal /proc/meminfo # 查看内存总量# grep MemFree /proc/meminfo # 查看空闲内存量# uptime # 查看系统运行时间、用户数、负载# cat /proc/loadavg # 查看系统负载 123456磁盘和分区# mount | column -t # 查看挂接的分区状态# fdisk -l # 查看所有分区# swapon -s # 查看所有交换分区# hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备)# dmesg | grep IDE # 查看启动时IDE设备检测状况 1234567网络# ifconfig # 查看所有网络接口的属性# iptables -L # 查看防火墙设置# route -n # 查看路由表# netstat -lntp # 查看所有监听端口# netstat -antp # 查看所有已经建立的连接# netstat -s # 查看网络统计信息 123456进程# ps -ef # 查看所有进程# top # 实时显示进程状态# ps -e | grep apt # 查看apt-get相关进程# sudo fuser -k 8000/tcp #关闭和端口8000相关进程 1234567用户# w # 查看活动用户# id &lt;用户名&gt; # 查看指定用户信息# last # 查看用户登录日志# cut -d: -f1 /etc/passwd # 查看系统所有用户# cut -d: -f1 /etc/group # 查看系统所有组# crontab -l # 查看当前用户的计划任务 123服务# chkconfig --list # 列出所有系统服务# chkconfig --list | grep on # 列出所有启动的系统服务 12程序# rpm -qa # 查看所有安装的软件包]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux操作命令</tag>
      </tags>
  </entry>
</search>
